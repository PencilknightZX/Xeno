import subprocess
import os
from utils.html_logger import HTMLLogger
from utils.logger import Logger


class ExploitTester:
    def __init__(self, logger=None):
        self.logger = logger if logger else Logger()
        self.exploitdb_path = "/opt/exploitdb"

    def search_exploit(self, search_term):
        """
        Search for exploits related to a service using searchsploit.
        """
        self.logger.log(f"[INFO] Searching for exploits using term: {search_term}")
        try:
            result = subprocess.run(
                ["searchsploit", search_term],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            if result.returncode == 0:
                self.logger.log(f"[INFO] Exploits found:\n{result.stdout}")
                return result.stdout
            else:
                self.logger.log(f"[WARNING] No exploits found for term: {search_term}")
                return None
        except Exception as e:
            self.logger.log(f"[ERROR] Failed to search exploits: {e}")
            return None

    def download_exploit(self, exploit_path):
        """
        Download an exploit from ExploitDB.
        """
        full_path = os.path.join(self.exploitdb_path, "exploits", exploit_path)
        local_copy = f"./downloads/{os.path.basename(exploit_path)}"

        self.logger.log(f"[INFO] Attempting to download exploit: {full_path}")
        os.makedirs("./downloads", exist_ok=True)

        if os.path.exists(full_path):
            try:
                subprocess.run(["cp", full_path, local_copy], check=True)
                self.logger.log(f"[INFO] Exploit downloaded to: {local_copy}")
                return local_copy
            except Exception as e:
                self.logger.log(f"[ERROR] Failed to copy exploit: {e}")
                return None
        else:
            self.logger.log(f"[ERROR] Exploit path not found: {full_path}")
            return None

    def make_executable(self, file_path):
        """
        Ensure the exploit file is executable.
        """
        if os.access(file_path, os.X_OK):
            self.logger.log(f"[INFO] Exploit is already executable: {file_path}")
            return True

        try:
            self.logger.log(f"[INFO] Making exploit executable: {file_path}")
            subprocess.run(["chmod", "+x", file_path], check=True)
            return True
        except Exception as e:
            self.logger.log(f"[ERROR] Failed to make exploit executable: {e}")
            return False

    def execute_exploit(self, exploit_file, target_ip):
        """
        Execute a downloaded exploit script against the target.
        """
        self.logger.log(f"[INFO] Attempting to execute exploit: {exploit_file} on target: {target_ip}")

        if not os.path.exists(exploit_file):
            self.logger.log(f"[ERROR] Exploit file does not exist: {exploit_file}")
            return None

        if not self.make_executable(exploit_file):
            self.logger.log(f"[ERROR] Cannot execute exploit; it is not executable: {exploit_file}")
            return None

        try:
            result = subprocess.run(
                [exploit_file, target_ip],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )
            if result.returncode == 0:
                self.logger.log(f"[INFO] Exploit execution successful:\n{result.stdout}")
            else:
                self.logger.log(f"[WARNING] Exploit execution failed with code {result.returncode}:\n{result.stderr}")
            return result.stdout
        except Exception as e:
            self.logger.log(f"[ERROR] Exploit execution failed: {e}")
            return None

    def run_exploit_testing(self, service_data, target_ip, ssid=None, html_logger=None):
        """
        Run exploit testing for identified vulnerabilities.
        """
        self.logger.log(f"[INFO] Starting exploit testing for target: {target_ip}")

        service_name = service_data.get("name")
        service_version = service_data.get("version")
        port = service_data.get("port")

        # Debugging service information
        self.logger.log(f"[DEBUG] Service details - Name: {service_name}, Version: {service_version}, Port: {port}")

        if not service_name or not service_version:
            self.logger.log(f"[WARNING] Missing service name or version for target: {target_ip}")
            return

        search_term = f"{service_name} {service_version}"
        search_results = self.search_exploit(search_term)

        if not search_results:
            self.logger.log(f"[WARNING] No exploits found for {search_term}")
            return

        # Parse searchsploit output for relevant paths
        exploit_paths = []
        for line in search_results.splitlines():
            if "|" in line and "/exploitdb/" in line:
                parts = line.split("|")
                path = parts[-1].strip()
                exploit_paths.append(path)

        self.logger.log(f"[INFO] Found {len(exploit_paths)} potential exploits")

        for exploit_path in exploit_paths:
            downloaded_exploit = self.download_exploit(exploit_path)
            if not downloaded_exploit:
                self.logger.log(f"[WARNING] Failed to download exploit: {exploit_path}")
                continue

            execution_result = self.execute_exploit(downloaded_exploit, target_ip)
            if not execution_result:
                self.logger.log(f"[WARNING] Exploit execution failed for: {downloaded_exploit}")

            # Append results to the HTML log
            if html_logger and ssid:
                html_logger.append_exploit_results_to_html(
                    ssid,
                    {
                        "target_ip": target_ip,
                        "service_name": service_name,
                        "service_version": service_version,
                        "port": port,
                        "exploit_path": exploit_path,
                        "execution_result": execution_result,
                    },
                )

        self.logger.log(f"[INFO] Exploit testing completed for target: {target_ip}")
